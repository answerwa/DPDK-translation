# 3. [从源码编译DPDK目标](http://dpdk.org/doc/guides/linux_gsg/build_dpdk.html)

> **注意**
>
> 此过程的一部分操作也可以使用本文档的[快速入门设置脚本](https://github.com/answerwa/DPDK-translation/blob/master/%E9%92%88%E5%AF%B9Linux%E7%9A%84%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/2.%20%E7%B3%BB%E7%BB%9F%E9%9C%80%E6%B1%82.md#6-快速入门设置脚本)部分中描述的安装脚本进行。

## 3.1. 安装DPDK和浏览源码

首先，解压包，并进入已解压的源码目录中：

```sh
tar xJf dpdk-<version>.tar.xz
cd dpdk-<version>
```

DPDK由几个目录组成：

- lib: DPDK库源码
- drivers: DPDK轮询模式驱动源码
- app: DPDK应用程序源码（自动测试）
- examples: DPDK示例源码
- config, buildtools, mk: 框架相关的makfiles，脚本和配置

## 3.2. 安装DPDK目标环境

DPDK目标的格式是：

```sh
ARCH-MACHINE-EXECENV-TOOLCHAIN
```

比如：

- `ARCH` 可以是： `i686`, `x86_64`, `ppc_64`
- `MACHINE` 可以是： `native`, `power8`
- `EXECENV` 可以是： `linuxapp`, `bsdapp`
- `TOOLCHAIN` 可以是： `gcc`, `icc`

要安装的目标取决于主机上安装的32位和/或64位软件包和编译器。可以在DPDK/config目录下找到可用的目标文件。忽略defconfig_前缀。

> **注意**
>
> 配置文件随 `RTE_MACHINE` 优化级别一起提供。在配置文件中，`RTE_MACHINE` 的值设置为本机，这意味着编译的软件已针对其构建的平台进行了调整。有关此设置的更多信息及其可能的值，请参阅*DPDK程序员指南*。

使用inter®C++编译器（icc）时，应分别对64位或32位调用以下命令之一。注意，此shell脚本会更新 `$PATH` 变量，因此不应在同一会话中执行。此外，验证编译器的安装目录，因为路径可能不同：

```sh
source /opt/intel/bin/iccvars.sh intel64
source /opt/intel/bin/iccvars.sh ia32
```

要安装和创建目标，请在DPDK顶级目录中使用 `make install T=<target>` 命令。

例如，用icc编译64位目标，运行：

```sh
make install T=x86_64-native-linuxapp-icc
```

要使用gcc编译32位，运行命令应为：

```sh
make install T=i686-native-linuxapp-gcc
```

为了准备目标而不构建它，例如，如果在编译之前需要进行配置更改，请使用 `make config T=<target>` 命令：

```sh
make config T=x86_64-native-linuxapp-gcc
```

> **警告**
>
> 要使用任何内核模块，例如 `igb_uio`， `kni`， 必须使用与目标上运行的内核相同内核进行编译。如果DPDK未在目标机器上构建，应使用 `RTE_KERNELDIR` 环境变量将编译指向要在目标机器上使用的内核版本的副本。

创建目标环境后，用户可以移动到目标环境目录，并继续修改代码并重新编译。 用户还可以通过编辑build目录中的.config文件对编译时DPDK配置进行修改。 （这是从顶级配置目录中的defconfig文件的本地副本）。

```sh
cd x86_64-native-linuxapp-gcc
vi .config
make
```

此外，make clean命令可用于删除任何现有的编译文件，以便后续完整，干净地重建代码。

## 3.3. Browsing the Installed DPDK Environment Target

Once a target is created it contains all libraries, including poll-mode drivers, and header files for the DPDK environment that are required to build customer applications. In addition, the test and testpmd applications are built under the build/app directory, which may be used for testing. A kmod directory is also present that contains kernel modules which may be loaded if needed.

## 3.4. Loading Modules to Enable Userspace IO for DPDK

To run any DPDK application, a suitable uio module can be loaded into the running kernel. In many cases, the standard `uio_pci_generic` module included in the Linux kernel can provide the uio capability. This module can be loaded using the command

```
sudo modprobe uio_pci_generic

```

Note

`uio_pci_generic` module doesn’t support the creation of virtual functions.

As an alternative to the `uio_pci_generic`, the DPDK also includes the igb_uio module which can be found in the kmod subdirectory referred to above. It can be loaded as shown below:

```
sudo modprobe uio
sudo insmod kmod/igb_uio.ko

```

Note

For some devices which lack support for legacy interrupts, e.g. virtual function (VF) devices, the `igb_uio` module may be needed in place of `uio_pci_generic`.

Since DPDK release 1.7 onward provides VFIO support, use of UIO is optional for platforms that support using VFIO.

## 3.5. Loading VFIO Module

To run an DPDK application and make use of VFIO, the `vfio-pci` module must be loaded:

```
sudo modprobe vfio-pci

```

Note that in order to use VFIO, your kernel must support it. VFIO kernel modules have been included in the Linux kernel since version 3.6.0 and are usually present by default, however please consult your distributions documentation to make sure that is the case.

Also, to use VFIO, both kernel and BIOS must support and be configured to use IO virtualization (such as Intel® VT-d).

Note

`vfio-pci` module doesn’t support the creation of virtual functions.

For proper operation of VFIO when running DPDK applications as a non-privileged user, correct permissions should also be set up. This can be done by using the DPDK setup script (called dpdk-setup.sh and located in the usertools directory).

## 3.6. Binding and Unbinding Network Ports to/from the Kernel Modules

As of release 1.4, DPDK applications no longer automatically unbind all supported network ports from the kernel driver in use. Instead, all ports that are to be used by an DPDK application must be bound to the `uio_pci_generic`, `igb_uio` or `vfio-pci` module before the application is run. Any network ports under Linux* control will be ignored by the DPDK poll-mode drivers and cannot be used by the application.

Warning

The DPDK will, by default, no longer automatically unbind network ports from the kernel driver at startup. Any ports to be used by an DPDK application must be unbound from Linux* control and bound to the `uio_pci_generic`, `igb_uio` or `vfio-pci` module before the application is run.

To bind ports to the `uio_pci_generic`, `igb_uio` or `vfio-pci` module for DPDK use, and then subsequently return ports to Linux* control, a utility script called dpdk-devbind.py is provided in the usertools subdirectory. This utility can be used to provide a view of the current state of the network ports on the system, and to bind and unbind those ports from the different kernel modules, including the uio and vfio modules. The following are some examples of how the script can be used. A full description of the script and its parameters can be obtained by calling the script with the `--help` or `--usage` options. Note that the uio or vfio kernel modules to be used, should be loaded into the kernel before running the `dpdk-devbind.py` script.

Warning

Due to the way VFIO works, there are certain limitations to which devices can be used with VFIO. Mainly it comes down to how IOMMU groups work. Any Virtual Function device can be used with VFIO on its own, but physical devices will require either all ports bound to VFIO, or some of them bound to VFIO while others not being bound to anything at all.

If your device is behind a PCI-to-PCI bridge, the bridge will then be part of the IOMMU group in which your device is in. Therefore, the bridge driver should also be unbound from the bridge PCI device for VFIO to work with devices behind the bridge.

Warning

While any user can run the dpdk-devbind.py script to view the status of the network ports, binding or unbinding network ports requires root privileges.

To see the status of all network ports on the system:

```
./usertools/dpdk-devbind.py --status

Network devices using DPDK-compatible driver
============================================
0000:82:00.0 '82599EB 10-GbE NIC' drv=uio_pci_generic unused=ixgbe
0000:82:00.1 '82599EB 10-GbE NIC' drv=uio_pci_generic unused=ixgbe

Network devices using kernel driver
===================================
0000:04:00.0 'I350 1-GbE NIC' if=em0  drv=igb unused=uio_pci_generic *Active*
0000:04:00.1 'I350 1-GbE NIC' if=eth1 drv=igb unused=uio_pci_generic
0000:04:00.2 'I350 1-GbE NIC' if=eth2 drv=igb unused=uio_pci_generic
0000:04:00.3 'I350 1-GbE NIC' if=eth3 drv=igb unused=uio_pci_generic

Other network devices
=====================
<none>

```

To bind device `eth1`,``04:00.1``, to the `uio_pci_generic` driver:

```
./usertools/dpdk-devbind.py --bind=uio_pci_generic 04:00.1

```

or, alternatively,

```
./usertools/dpdk-devbind.py --bind=uio_pci_generic eth1

```

To restore device `82:00.0` to its original kernel binding:

```
./usertools/dpdk-devbind.py --bind=ixgbe 82:00.0
```